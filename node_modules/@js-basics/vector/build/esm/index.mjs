function P(r){return Array.isArray(r)||ArrayBuffer.isView(r)}function ft(r,t){let{x:e,y:n,z:o}=t,{x:s,y:i,z:u,w:h}=r,c=h*e+i*o-u*n,f=h*n+u*e-s*o,d=h*o+s*n-i*e,V=-s*e-i*n-u*o,M=c*h+V*-s+f*-u-d*-i,at=f*h+V*-i+d*-s-c*-u,a=d*h+V*-u+c*-i-f*-s;return new t.constructor(M,at,a)}var Mt=Math.PI,Vt=Math.PI*2;function G(r){let t=r%Vt;return t<-Mt?t+=Vt:t>Mt&&(t-=Vt),t}function Wt(r){return r>-1?r<1?Math.acos(r):0:Mt}function Yt(r,[t,e,n]){let[o,s,i]=r;return new r.constructor(new o.constructor(o.x*t.x+s.x*t.y+i.x*t.z,o.y*t.x+s.y*t.y+i.y*t.z,o.z*t.x+s.z*t.y+i.z*t.z),new o.constructor(o.x*e.x+s.x*e.y+i.x*e.z,o.y*e.x+s.y*e.y+i.y*e.z,o.z*e.x+s.z*e.y+i.z*e.z),new o.constructor(o.x*n.x+s.x*n.y+i.x*n.z,o.y*n.x+s.y*n.y+i.y*n.z,o.z*n.x+s.z*n.y+i.z*n.z))}function Ut(r,{x:t,y:e,z:n}){let[o,s,i]=r;return new o.constructor(o.x*t+s.x*e+i.x*n,o.y*t+s.y*e+i.y*n,o.z*t+s.z*e+i.z*n)}function Zt(r,[t,e,n]){return new r.constructor(r.dot(t),r.dot(e),r.dot(n))}function x(r){return typeof r=="number"||(r==null?void 0:r.constructor)===Number}var et=0,Ct=1,At=2,Tt=3,mt=9999999999999,pt=void 0,jt=Symbol("vector length"),dt=Symbol("get source"),Qt=Symbol("checked"),S=pt,k,j,er=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],bt=[],A=-1,qt=!1,yt=[];function Nt(r,t,e){S=r,A=-1,j=1;let n=t(e);if(!x(n))throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);return n}function wt(r){let t=r[dt];return t?t(r).length:r[jt]||3}function nr(r,t){return wt(r)>wt(t)?r:t}function or(r,t){if(j+=1,t===mt)return j;if(t>=wt(r))return 0;let e=r[dt];if(e)return 1*e(r)[t];if(t===et)return 1*r.x;if(t===Ct)return 1*r.y;if(t===At)return 1*r.z;if(t===Tt)return 1*r.w}function $t(r,t,e){let n=r[dt];if(n){n(r)[t]=e;return}if(t===et){r.x=e;return}if(t===Ct){r.y=e;return}t===At&&(r.z=e),t===Tt&&(r.w=e)}function q(r,t){if(typeof r!="function")throw new Error("no function assigned");if(S!==pt)throw new Error("something wrong, do you use calc() inside calc?");try{let e=typeof t>"u",n=typeof t=="function",o=!n&&!e?t:void 0,s=Nt(et,r,o);if(e&&typeof k>"u")return s;let i=k?wt(k):0;if(i===mt){if(!r[Qt]){let f=Nt(mt,r),d=er[j];if(Math.abs(f-d)>Number.EPSILON)throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);r[Qt]=!0}let c=bt[0];for(let f=1;f<j-1;f+=1){let d=bt[f];if(!c.multiply)throw new Error(`cannot find method multiply() on ${c}`);c=c.multiply(d)}return c}let u=n?t.length:i;if(u||(u=i),u<i)throw new Error("Your assigned result Vector cant use higher space Operands than it has");let h=new Array(u);h[0]=s,o&&$t(o,S,h[0]);for(let c=1;c<u;c+=1){let f=Nt(c,r,o);h[c]=f,o&&$t(o,S,f)}return e?new k.constructor(...h):n?t(...h):o}finally{S=pt,k=void 0}}function N(r,t){let e=r.prototype;e[dt]=t;let n="valueOf",o=e[n];e[n]=function(){return S===et&&(k=k?nr(k,this):this,bt[j-1]=this),S===pt?o.call(this):or(this,S)}}function _t(r){return function(...t){if(S===et){if(qt)return r.apply(this,t);try{qt=!0,A+=1;let e=r.apply(this,t);return yt[A]=e,e}finally{qt=!1}}return S===Ct||S===At||S===Tt?(A+=1,yt[A]):r.apply(this,t)}}function m(r,t){let e=r.prototype,n=e[t];e[t]=_t(n)}function B(r,t){let e=r.prototype,n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{get:_t(function(){return n.get.call(this)})})}function X(r,t){let e=r.prototype;Object.defineProperty(e,jt,{value:t})}function xt(r){X(r,mt)}function E(r){return _t(r)}function sr(r){let t="";return r&&(t=`${r}-`),t}function b(r,t,e={}){let n=sr(r);return Object.entries(t).forEach(([o,s])=>{e[`--${n}${o}`]=s}),e}var Rt=0,Ft=1,O=Symbol("axes");function ir(r,t,e,n){let o=Math.atan2(r,t),s=Math.atan2(e,n);return G(o-s)}function Bt(r){return r*r}var g=class{constructor(t,e){typeof t=="function"?q(t,(n,o)=>{this[O]=[n,o]}):P(t)?this[O]=[...t]:t&&x(t.x)?this[O]=[t.x||0,t.y||0]:this[O]=[t||0,e||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){let{length:t}=this;return new this.constructor(this.x/t,this.y/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y}getRad(){return G(Math.atan2(this.y,this.x))}angleTo(t){return ir(this.y,this.x,t.y,t.x)}rotate(t){let e=Math.sin(t),n=Math.cos(t),o=this.x*n-this.y*e,s=this.x*e+this.y*n;return new this.constructor(o,s)}distance(t){return Math.sqrt(Bt(this.x-t.x)+Bt(this.y-t.y))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y}toJSON(){return{x:this.x,y:this.y}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return b(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}get length(){return Math.sqrt(this.lengthSq)}get lensq(){return this.lengthSq}get len(){return this.length}get x(){return this[O][Rt]}set x(t){throw new Error("set x() not implemented")}get y(){return this[O][Ft]}set y(t){throw new Error("set y() not implemented")}get z(){throw new Error("get z() not implemented")}set z(t){throw new Error("set z() not implemented")}[Symbol.iterator](){return this[O].values()}};N(g);X(g,2);m(g,"dot");m(g,"angleTo");m(g,"distance");m(g,"toArray");m(g,"getRad");B(g,"length");B(g,"lengthSq");var W=class extends g{set x(t){this[O][Rt]=t}set y(t){this[O][Ft]=t}get x(){return this[O][Rt]}get y(){return this[O][Ft]}calc(t){return q(t,this)}clone(){return new W(this.x,this.y)}},T=class extends g{toPoint(){return new W(this.x,this.y)}};var cr=E((r,t)=>new W(r,t)),ur=(r,t)=>cr(r,t),hr=E((r,t)=>new T(r,t)),gt=(r,t)=>hr(r,t),Xr=gt(0,0),Wr=gt(0,-1),Yr=gt(-1,0);var K=0,v=1,tt=2,l=Symbol("axes");function Jt(r){return r*r}var w=class{constructor(t,e,n){typeof t=="function"?q(t,(o,s,i)=>{this[l]=[o,s,i]}):P(t)?this[l]=[...t]:t&&x(t.x)?this[l]=[t.x||0,t.y||0,t.z||0]:this[l]=[t||0,e||0,n||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){let{length:t}=this;return new this.constructor(this.x/t,this.y/t,this.z/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new this.constructor(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}crossNormalize(t){let e=this.cross(t),{length:n}=e;return e[l][K]/=n,e[l][v]/=n,e[l][tt]/=n,e}cn(t){return this.crossNormalize(t)}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length)}}angleTo(t){return G(Wt(this.dot(t)/(this.length*t.length)))}multiply(t){return t.x===void 0?this.multiplyMat3(t):t.w===void 0?this.multiplyVec3(t):ft(t,this)}multiplyMat3(t){return Zt(this,t)}multiplyVec3({x:t,y:e,z:n}){return new this.constructor(this.x*t,this.y*e,this.z*n)}distance(t){return Math.sqrt(Jt(this.x-t.x)+Jt(this.y-t.y)+Jt(this.z-t.z))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y,this.z]}swizzle(t){let e=t.split("").map(n=>this[n]);return e.length===2?new T(e[0],e[1]):new this.constructor(e[0],e[1],e[2])}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}toJSON(){return{x:this.x,y:this.y,z:this.z}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return b(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}set lengthSq(t){throw new Error("set lengthSq() not implemented")}get length(){return Math.sqrt(this.lengthSq)}set length(t){throw new Error("set length() not implemented")}get lensq(){return this.lengthSq}set lensq(t){throw new Error("set lensq() not implemented")}get len(){return this.length}set len(t){throw new Error("set len() not implemented")}get x(){return this[l][K]}set x(t){throw new Error("set x() not implemented")}get y(){return this[l][v]}set y(t){throw new Error("set y() not implemented")}get z(){return this[l][tt]}set z(t){throw new Error("set z() not implemented")}get xy(){return new T(this[l][K],this[l][v])}set xy(t){throw new Error("set xz() not implemented")}get xz(){return new T(this[l][K],this[l][tt])}set xz(t){throw new Error("set xz() not implemented")}get yz(){return new T(this[l][v],this[l][tt])}set yz(t){throw new Error("set yz() not implemented")}[Symbol.iterator](){return this[l].values()}};N(w);X(w,3);m(w,"dot");m(w,"cross");m(w,"crossNormalize");m(w,"toAngles");m(w,"angleTo");m(w,"rotate");m(w,"distance");m(w,"toArray");B(w,"length");B(w,"lengthSq");var _=class extends w{set x(t){this[l][K]=t}set y(t){this[l][v]=t}set z(t){this[l][tt]=t}get x(){return this[l][K]}get y(){return this[l][v]}get z(){return this[l][tt]}calc(t){return q(t,this)}clone(){return new _(this.x,this.y,this.z)}},nt=class extends w{toVector(){return new _(this.x,this.y,this.z)}clone(){return this}};var lr=E((r,t,e)=>new _(r,t,e)),ar=(r,t,e)=>lr(r,t,e),fr=E((r,t,e)=>new nt(r,t,e)),C=(r,t,e)=>fr(r,t,e),Br=C(0,0,0),ot=C(0,0,-1),Kr=C(0,0,1),st=C(-1,0,0),It=C(1,0,0),it=C(0,1,0),vr=C(0,-1,0),te=C(1,1,1);var R=Symbol("angle rad"),Kt=Math.PI/180,oe=180/Math.PI,L=class{constructor(t){t instanceof L?this[R]=t[R]:this[R]=G(t*Kt)}valueOf(){return this[R]}toJSON(){return{angle:this[R]}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return b(t,this.toJSON(),e)}},ct=class extends L{set(t){t instanceof L?this[R]=t[R]:this[R]=G((t||0)*Kt)}},rt=class extends L{toDegree(){return new ct(this[R])}},yr=new rt(0);function Y(r){return new ct(r)}function mr(r){return r instanceof rt?r:r?new rt(r):yr}function vt(r){return x(r)||r instanceof L}var F=0,J=1,I=2,D=3,y=Symbol("axes"),pr=Symbol("forward cache"),wr=Symbol("left cache"),dr=Symbol("up cache"),xr=Symbol("inverse cache");function gr([r,t,e,n]){return Math.sqrt(r*r+t*t+e*e+n*n)}function tr(r){let t=gr(r);r[F]/=t,r[J]/=t,r[I]/=t,r[D]/=t}function zr(r,t){let e=r.normalize(),n=t.crossNormalize(e),o=e.crossNormalize(n),s=n.x,i=n.y,u=n.z,h=o.x,c=o.y,f=o.z,d=e.x,V=e.y,M=e.z,at=s+c+M,a=new Array(4);if(at>0){let z=Math.sqrt(at+1);return a[D]=z*.5,z=.5/z,a[F]=(f-V)*z,a[J]=(d-u)*z,a[I]=(i-h)*z,a}if(s>=c&&s>=M){let z=Math.sqrt(1+s-c-M),H=.5/z;return a[F]=.5*z,a[J]=(i+h)*H,a[I]=(u+d)*H,a[D]=(f-V)*H,a}if(c>M){let z=Math.sqrt(1+c-s-M),H=.5/z;return a[F]=(h+i)*H,a[J]=.5*z,a[I]=(V+f)*H,a[D]=(d-u)*H,a}let Xt=Math.sqrt(1+M-s-c),Ot=.5/Xt;return a[F]=(d+u)*Ot,a[J]=(V+f)*Ot,a[I]=.5*Xt,a[D]=(i-h)*Ot,a}function Sr(r,t){let e=new Array(4),n=t*.5,o=Math.sin(n),s=Math.cos(n);return e[F]=o*r.x,e[J]=o*r.y,e[I]=o*r.z,e[D]=s,e}function Dt(r,t,e,n){if(x(r))return[r,t,e,n];if(P(r))return[...r];if(vt(t))return Sr(r,t);if(r&&t)return zr(r,t)}function rr(r,t,e,n){return r&&x(r.w)?Dt(r.x,r.y,r.z,r.w):Dt(r,t,e,n)||[0,0,0,1]}var U=class{constructor(t,e,n,o){this[y]=rr(t,e,n,o),tr(this[y])}set(t,e,n,o){throw new Error("set x() not implemented")}multiply(t,e,n,o){if(x(t.w))return this.multiplyQuaternion(t);let s=Dt(t,e,n,o);return s?this.multiplyQuaternion(new this.constructor(s)):this.multiplyVector(t)}multiplyVector(t){return ft(this,t)}multiplyQuaternion(t){let e=this.x,n=this.y,o=this.z,s=this.w,i=t.x,u=t.y,h=t.z,c=t.w,f=s*i+e*c+n*h-o*u,d=s*u+n*c+o*i-e*h,V=s*h+o*c+e*u-n*i,M=s*c-e*i-n*u-o*h;return new this.constructor(f,d,V,M)}mul(t,e,n,o){return this.multiply(t,e,n,o)}get inverse(){let{x:t,y:e,z:n,w:o}=this;return this.constructor(t*-1,e*-1,n*-1,o)}get inv(){return this.inverse}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}get left(){return this.multiplyVector(st)}get dir(){return this.multiplyVector(ot)}get up(){return this.multiplyVector(it)}get[0](){return this.left}get[1](){return this.dir}get[2](){return this.up}get x(){return this[y][F]}set x(t){throw new Error("set x() not implemented")}get y(){return this[y][J]}set y(t){throw new Error("set y() not implemented")}get z(){return this[y][I]}set z(t){throw new Error("set z() not implemented")}get w(){return this[y][D]}set w(t){throw new Error("set w() not implemented")}toJSON(){let{x:t,y:e,z:n,w:o}=this;return{x:t,y:e,z:n,w:o,a1:1-e*e*2-n*n*2,a2:t*e*2-n*o*2,a3:t*n*2+e*o*2,b1:t*e*2+n*o*2,b2:1-t*t*2-n*n*2,b3:e*n*2-t*o*2,c1:t*n*2-e*o*2,c2:e*n*2+t*o*2,c3:1-t*t*2-e*e*2}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return b(t,this.toJSON(),e)}};N(U);xt(U);var ut=class extends U{set(t,e,n,o){t instanceof U?this[y]=[...t[y]]:(this[y]=rr(t,e,n,o),tr(this[y]))}set x(t){this[y][F]=t}set y(t){this[y][J]=t}set z(t){this[y][I]=t}set w(t){this[y][D]=t}get x(){return this[y][F]}get y(){return this[y][J]}get z(){return this[y][I]}get w(){return this[y][D]}};function zt(r,t,e){let n=r[t];return n||(n=e(),r[t]=n),n}var ht=class extends U{get left(){return zt(this,wr,()=>this.multiplyVector(st))}get dir(){return zt(this,pr,()=>this.multiplyVector(ot))}get up(){return zt(this,dr,()=>this.multiplyVector(it))}get inverse(){return zt(this,xr,()=>{let{x:t,y:e,z:n,w:o}=this;return this.constructor(t*-1,e*-1,n*-1,o)})}},ae=new ut,Er=E((r,t,e,n)=>new ut(r,t,e,n)),Or=(r,t,e,n)=>Er(r,t,e,n),Vr=E((r,t,e,n)=>new ht(r,t,e,n)),St=(r,t,e,n)=>Vr(r,t,e,n),Mr=new ht(st,Y(90));function qr({alpha:r,beta:t,gamma:e},n){let o=St(it,Y(r)).mul(It,Y(t)).mul(ot,Y(e)).mul(Mr);return o=St(o.dir,Y(n)).mul(o),o}var Nr=St(0,0,0,1);var Pt=0,Gt=1,kt=2,Lt=3,p=Symbol("axes"),Z=class{constructor(t,e,n,o){typeof t=="function"?q(t,(s,i,u,h)=>{this[p]=[s,i,u,h]}):P(t)?this[p]=[...t]:t&&x(t.x)?this[p]=[t.x||0,t.y||0,t.z||0,t.w||0]:this[p]=[t||0,e||0,n||0,o||0]}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}toArray(){return[this.x,this.y,this.z,this.w]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}toJSON(){return{x:this.x,y:this.y,z:this.z,w:this.w}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return b(t,this.toJSON(),e)}get x(){return this[p][Pt]}set x(t){throw new Error("set x() not implemented")}get y(){return this[p][Gt]}set y(t){throw new Error("set y() not implemented")}get z(){return this[p][kt]}set z(t){throw new Error("set z() not implemented")}get w(){return this[p][Lt]}set w(t){throw new Error("set w() not implemented")}[Symbol.iterator](){return this[p].values()}};N(Z);X(Z,4);m(Z,"toArray");var Q=class extends Z{set x(t){this[p][Pt]=t}set y(t){this[p][Gt]=t}set z(t){this[p][kt]=t}set w(t){this[p][Lt]=t}get x(){return this[p][Pt]}get y(){return this[p][Gt]}get z(){return this[p][kt]}get w(){return this[p][Lt]}calc(t){return q(t,this)}clone(){return new Q(this.x,this.y)}},Et=class extends Z{toColor(){return new Q(this.x,this.y,this.z,this.w)}};var br=E((r,t,e,n)=>new Q(r,t,e,n)),Cr=(r,t,e,n)=>br(r,t,e,n),Ar=E((r,t,e,n)=>new Et(r,t,e,n)),Tr=(r,t,e,n)=>Ar(r,t,e,n);var lt=Symbol("data"),$=class{constructor(...t){this[lt]=t}get[0](){return this[lt][0]}set[0](t){throw new Error("set [0] not implemented")}get[1](){return this[lt][1]}set[1](t){throw new Error("set [1] not implemented")}get[2](){return this[lt][2]}set[2](t){throw new Error("set [2] not implemented")}multiplyMat(t){return Yt(this,t)}multiplyVec(t){return Ut(this,t)}multiply(t){if(t instanceof $)return this.multiplyMat(t);let{x:e,y:n,z:o}=t;if(e===void 0||n===void 0||o===void 0)throw new Error(`multiply only works with mat3 and vec3, not supported ${t}`);return this.multiplyVec(t)}[Symbol.iterator](){return this[lt].values()}};N($);xt($);var Ht=class extends ${};var _r=Math.PI/180,Rr=180/Math.PI;function Fr(r){return r*_r}function Jr(r){return r*Rr}var Ee=_;export{Q as Color,ct as Degree,ot as FORWARD,Et as IColor,Nr as IDENTITY,rt as IDegree,Ht as IMat3,T as IPoint,ht as IQuaternion,nt as IVector,st as LEFT,W as Point,ut as Quaternion,It as RIGHT,it as UP,_ as Vector,nt as Victor,q as calc,Cr as color,Ee as default,Y as degree,Jr as degrees,qr as fromOrientation,Tr as icolor,mr as idegree,gt as ipoint,St as iquaternion,C as ivector,ur as point,Or as quaternion,Fr as radians,ar as vector,C as victor};
//# sourceMappingURL=index.mjs.map
