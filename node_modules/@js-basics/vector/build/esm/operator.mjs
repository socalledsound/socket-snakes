var D=Math.PI*2;function A(t){return typeof t=="number"||(t==null?void 0:t.constructor)===Number}var h=0,M=1,O=2,S=3,x=9999999999999,w=void 0,k=Symbol("vector length"),g=Symbol("get source"),N=Symbol("checked"),e=w,f,l,q=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],C=[],u=-1,b=!1,d=[];function m(t,n,r){e=t,u=-1,l=1;let o=n(r);if(!A(o))throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);return o}function z(t){let n=t[g];return n?n(t).length:t[k]||3}function I(t,n){return z(t)>z(n)?t:n}function T(t,n){if(l+=1,n===x)return l;if(n>=z(t))return 0;let r=t[g];if(r)return 1*r(t)[n];if(n===h)return 1*t.x;if(n===M)return 1*t.y;if(n===O)return 1*t.z;if(n===S)return 1*t.w}function R(t,n,r){let o=t[g];if(o){o(t)[n]=r;return}if(n===h){t.x=r;return}if(n===M){t.y=r;return}n===O&&(t.z=r),n===S&&(t.w=r)}function H(t,n){if(typeof t!="function")throw new Error("no function assigned");if(e!==w)throw new Error("something wrong, do you use calc() inside calc?");try{let r=typeof n>"u",o=typeof n=="function",c=!o&&!r?n:void 0,P=m(h,t,c);if(r&&typeof f>"u")return P;let a=f?z(f):0;if(a===x){if(!t[N]){let s=m(x,t),E=q[l];if(Math.abs(s-E)>Number.EPSILON)throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);t[N]=!0}let i=C[0];for(let s=1;s<l-1;s+=1){let E=C[s];if(!i.multiply)throw new Error(`cannot find method multiply() on ${i}`);i=i.multiply(E)}return i}let y=o?n.length:a;if(y||(y=a),y<a)throw new Error("Your assigned result Vector cant use higher space Operands than it has");let p=new Array(y);p[0]=P,c&&R(c,e,p[0]);for(let i=1;i<y;i+=1){let s=m(i,t,c);p[i]=s,c&&R(c,e,s)}return r?new f.constructor(...p):o?n(...p):c}finally{e=w,f=void 0}}function U(t,n){let r=t.prototype;r[g]=n;let o="valueOf",c=r[o];r[o]=function(){return e===h&&(f=f?I(f,this):this,C[l-1]=this),e===w?c.call(this):T(this,e)}}function V(t){return function(...n){if(e===h){if(b)return t.apply(this,n);try{b=!0,u+=1;let r=t.apply(this,n);return d[u]=r,r}finally{b=!1}}return e===M||e===O||e===S?(u+=1,d[u]):t.apply(this,n)}}function _(t,n){let r=t.prototype,o=r[n];r[n]=V(o)}function K(t,n){let r=t.prototype,o=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(r,n,{get:V(function(){return o.get.call(this)})})}function j(t,n){let r=t.prototype;Object.defineProperty(r,k,{value:n})}function Y(t){j(t,x)}function B(t){return V((...n)=>new t(...n))}function Q(t){return V(t)}export{B as cachedFactory,Q as cachedFunction,K as cachedGetter,_ as cachedMethod,U as cachedValueOf,Y as defineMatrixLength,j as defineVectorLength,H as operatorCalc};
//# sourceMappingURL=operator.mjs.map
