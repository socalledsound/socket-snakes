var b=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var j=Object.getOwnPropertyNames;var D=Object.prototype.hasOwnProperty;var F=(t,n)=>{for(var r in n)b(t,r,{get:n[r],enumerable:!0})},G=(t,n,r,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let e of j(n))!D.call(t,e)&&e!==r&&b(t,e,{get:()=>n[e],enumerable:!(o=T(n,e))||o.enumerable});return t};var H=t=>G(b({},"__esModule",{value:!0}),t);var J={};F(J,{cachedFactory:()=>Z,cachedFunction:()=>$,cachedGetter:()=>W,cachedMethod:()=>Q,cachedValueOf:()=>B,defineMatrixLength:()=>X,defineVectorLength:()=>I,operatorCalc:()=>Y});module.exports=H(J);var v=Math.PI*2;function N(t){return typeof t=="number"||(t==null?void 0:t.constructor)===Number}var h=0,O=1,S=2,P=3,x=9999999999999,w=void 0,q=Symbol("vector length"),g=Symbol("get source"),R=Symbol("checked"),c=w,f,l,U=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],M=[],u=-1,m=!1,d=[];function C(t,n,r){c=t,u=-1,l=1;let o=n(r);if(!N(o))throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);return o}function z(t){let n=t[g];return n?n(t).length:t[q]||3}function _(t,n){return z(t)>z(n)?t:n}function K(t,n){if(l+=1,n===x)return l;if(n>=z(t))return 0;let r=t[g];if(r)return 1*r(t)[n];if(n===h)return 1*t.x;if(n===O)return 1*t.y;if(n===S)return 1*t.z;if(n===P)return 1*t.w}function k(t,n,r){let o=t[g];if(o){o(t)[n]=r;return}if(n===h){t.x=r;return}if(n===O){t.y=r;return}n===S&&(t.z=r),n===P&&(t.w=r)}function Y(t,n){if(typeof t!="function")throw new Error("no function assigned");if(c!==w)throw new Error("something wrong, do you use calc() inside calc?");try{let r=typeof n>"u",o=typeof n=="function",e=!o&&!r?n:void 0,A=C(h,t,e);if(r&&typeof f>"u")return A;let a=f?z(f):0;if(a===x){if(!t[R]){let s=C(x,t),E=U[l];if(Math.abs(s-E)>Number.EPSILON)throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);t[R]=!0}let i=M[0];for(let s=1;s<l-1;s+=1){let E=M[s];if(!i.multiply)throw new Error(`cannot find method multiply() on ${i}`);i=i.multiply(E)}return i}let y=o?n.length:a;if(y||(y=a),y<a)throw new Error("Your assigned result Vector cant use higher space Operands than it has");let p=new Array(y);p[0]=A,e&&k(e,c,p[0]);for(let i=1;i<y;i+=1){let s=C(i,t,e);p[i]=s,e&&k(e,c,s)}return r?new f.constructor(...p):o?n(...p):e}finally{c=w,f=void 0}}function B(t,n){let r=t.prototype;r[g]=n;let o="valueOf",e=r[o];r[o]=function(){return c===h&&(f=f?_(f,this):this,M[l-1]=this),c===w?e.call(this):K(this,c)}}function V(t){return function(...n){if(c===h){if(m)return t.apply(this,n);try{m=!0,u+=1;let r=t.apply(this,n);return d[u]=r,r}finally{m=!1}}return c===O||c===S||c===P?(u+=1,d[u]):t.apply(this,n)}}function Q(t,n){let r=t.prototype,o=r[n];r[n]=V(o)}function W(t,n){let r=t.prototype,o=Object.getOwnPropertyDescriptor(r,n);Object.defineProperty(r,n,{get:V(function(){return o.get.call(this)})})}function I(t,n){let r=t.prototype;Object.defineProperty(r,q,{value:n})}function X(t){I(t,x)}function Z(t){return V((...n)=>new t(...n))}function $(t){return V(t)}
//# sourceMappingURL=operator.cjs.map
