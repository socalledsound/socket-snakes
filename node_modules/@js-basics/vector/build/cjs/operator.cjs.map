{
  "version": 3,
  "sources": ["../../src/operator.js", "../../src/utils/math.js"],
  "sourcesContent": ["import { isNumber } from './utils/math';\n\nconst X = 0;\nconst Y = 1;\nconst Z = 2;\nconst W = 3;\nconst CHECK_SUM = 9999999999999;\n\nconst DEFAULT = undefined;\nconst VECTOR_LENGTH = Symbol('vector length');\nconst GET_SOURCE = Symbol('get source');\nconst CHECKED = Symbol('checked');\n\nlet inProgress = DEFAULT;\nlet inVector;\nlet elCount;\nconst allChecks = [0, 1, 2, 6, 24, 120, 720, 5760, 51840, 518400, 5702400, 68428800, 889574400, 12454041600, 186810624000];\nconst collect = [];\n\nlet resultCacheIndex = -1;\nlet handlingCache = false;\nconst resultCache = [];\n\nfunction handleProgess (progess, alg, resVec) {\n  inProgress = progess;\n  resultCacheIndex = -1;\n  elCount = 1;\n\n  const res = alg(resVec);\n\n  if (!isNumber(res)) {\n    throw new Error(`\n      your assigned progress did not not return a primitive!\n      calc() does not support logical operators (|| && ==) directly\n\n      instead of calc(() => v1 || v2);\n      use        calc(() => +v1 || +v2);\n\n      instead of calc(() => v1);\n      use        calc(v1);\n      `);\n  }\n  return res;\n}\n\nfunction getVectorLength (vec) {\n  const getSource = vec[GET_SOURCE];\n  if (getSource) {\n    return getSource(vec).length;\n  }\n  return vec[VECTOR_LENGTH] || 3;\n}\n\nfunction maxVector (v1, v2) {\n  if (getVectorLength(v1) > getVectorLength(v2)) {\n    return v1;\n  }\n  return v2;\n}\n\nfunction getVectorValue (vec, index) {\n  elCount += 1;\n\n  if (index === CHECK_SUM) {\n    return elCount;\n  }\n\n  if (index >= getVectorLength(vec)) {\n    return 0;\n  }\n\n  const getSource = vec[GET_SOURCE];\n  if (getSource) {\n    return 1.0 * getSource(vec)[index];\n  }\n  if (index === X) {\n    return 1.0 * vec.x;\n  }\n  if (index === Y) {\n    return 1.0 * vec.y;\n  }\n  if (index === Z) {\n    return 1.0 * vec.z;\n  }\n  if (index === W) {\n    return 1.0 * vec.w;\n  }\n  // really?\n  return undefined;\n}\n\nfunction setVectorValue (vec, index, value) {\n  const getSource = vec[GET_SOURCE];\n  if (getSource) {\n    getSource(vec)[index] = value;\n    return;\n  }\n  if (index === X) {\n    vec.x = value;\n    return;\n  }\n  if (index === Y) {\n    vec.y = value;\n    return;\n  }\n  if (index === Z) {\n    vec.z = value;\n  }\n  if (index === W) {\n    vec.w = value;\n  }\n}\n\nexport function operatorCalc (alg, result) {\n  if (typeof alg !== 'function') {\n    throw new Error('no function assigned');\n  }\n  if (inProgress !== DEFAULT) {\n    throw new Error('something wrong, do you use calc() inside calc?');\n  }\n  try {\n    const noRes = typeof result === 'undefined';\n    const funRes = typeof result === 'function';\n    const resVec = !funRes && !noRes ? result : undefined;\n    const x = handleProgess(X, alg, resVec);\n\n    if (noRes && typeof inVector === 'undefined') {\n      return x;\n    }\n\n    const inLen = inVector ? getVectorLength(inVector) : 0;\n    if (inLen === CHECK_SUM) {\n      if (!alg[CHECKED]) {\n        const checkSum = handleProgess(CHECK_SUM, alg);\n\n        const sum = allChecks[elCount];\n        if (Math.abs(checkSum - sum) > Number.EPSILON) {\n          throw new Error(`\n            algebraic multiplication works only in calls with *\n\n            calc(() => v * m);\n            calc(() => m * v);\n            calc(() => m * m);\n            calc(() => m * m * v);\n\n            `);\n        }\n        alg[CHECKED] = true;\n      }\n\n      let last = collect[0];\n      for (let i = 1; i < elCount - 1; i += 1) {\n        const current = collect[i];\n        if (!last.multiply) {\n          throw new Error(`cannot find method multiply() on ${last}`);\n        }\n        last = last.multiply(current);\n      }\n      return last;\n    }\n    let len = funRes ? result.length : inLen;\n    if (!len) {\n      len = inLen;\n    }\n    if (len < inLen) {\n      throw new Error('Your assigned result Vector cant use higher space Operands than it has');\n    }\n    const target = new Array(len);\n    target[0] = x;\n    if (resVec) {\n      setVectorValue(resVec, inProgress, target[0]);\n    }\n    for (let i = 1; i < len; i += 1) {\n      const val = handleProgess(i, alg, resVec);\n      target[i] = val;\n      if (resVec) {\n        setVectorValue(resVec, inProgress, val);\n      }\n    }\n\n    if (noRes) {\n      return new inVector.constructor(...target);\n    }\n    if (funRes) {\n      return result(...target);\n    }\n    return resVec;\n  } finally {\n    inProgress = DEFAULT;\n    inVector = undefined;\n  }\n}\n\nexport function cachedValueOf (VectorClass, getSource) {\n  const Vector = VectorClass.prototype;\n  Vector[GET_SOURCE] = getSource;\n  const name = 'valueOf';\n  const org = Vector[name];\n\n  Vector[name] = function () {\n    if (inProgress === X) {\n      inVector = inVector ? maxVector(inVector, this) : this;\n      collect[elCount - 1] = this;\n    }\n    if (inProgress === DEFAULT) {\n      return org.call(this);\n    }\n    return getVectorValue(this, inProgress);\n  };\n}\n\nfunction bindCache (org) {\n  return function (...args) {\n    if (inProgress === X) {\n      if (handlingCache) {\n        return org.apply(this, args);\n      }\n      try {\n        handlingCache = true;\n\n        resultCacheIndex += 1;\n        const res = org.apply(this, args);\n        resultCache[resultCacheIndex] = res;\n        return res;\n      } finally {\n        handlingCache = false;\n      }\n    }\n    if (inProgress === Y) {\n      resultCacheIndex += 1;\n      return resultCache[resultCacheIndex];\n    }\n    if (inProgress === Z) {\n      resultCacheIndex += 1;\n      return resultCache[resultCacheIndex];\n    }\n    if (inProgress === W) {\n      resultCacheIndex += 1;\n      return resultCache[resultCacheIndex];\n    }\n    return org.apply(this, args);\n  };\n}\n\nexport function cachedMethod (VectorClass, name) {\n  const Vector = VectorClass.prototype;\n  const org = Vector[name];\n  Vector[name] = bindCache(org);\n}\n\nexport function cachedGetter (VectorClass, name) {\n  const Vector = VectorClass.prototype;\n  const desc = Object.getOwnPropertyDescriptor(Vector, name);\n  const org = function () {\n    return desc.get.call(this);\n  };\n\n  Object.defineProperty(Vector, name, {\n    get: bindCache(org),\n  });\n}\n\nexport function defineVectorLength (VectorClass, value) {\n  const Vector = VectorClass.prototype;\n\n  Object.defineProperty(Vector, VECTOR_LENGTH, { value });\n}\n\nexport function defineMatrixLength (MatrixClass) {\n  defineVectorLength(MatrixClass, CHECK_SUM);\n}\n\nexport function cachedFactory (VectorClass) {\n  return bindCache((...args) => new VectorClass(...args));\n}\n\nexport function cachedFunction (fun) {\n  return bindCache(fun);\n}\n", "export function isArray (arr) {\n  return Array.isArray(arr) || ArrayBuffer.isView(arr);\n}\n\n// http://schteppe.github.io/cannon.js/docs/files/src_math_Quaternion.js.html\nexport function multQuatVec (quat, vec) {\n  const {\n    x, y, z\n  } = vec;\n  const {\n    x: qx, y: qy, z: qz, w: qw\n  } = quat;\n\n  const ix = qw * x + qy * z - qz * y;\n  const iy = qw * y + qz * x - qx * z;\n  const iz = qw * z + qx * y - qy * x;\n  const iw = -qx * x - qy * y - qz * z;\n  const rx = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  const ry = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  const rz = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  return new vec.constructor(rx, ry, rz);\n}\n\nconst angle180 = Math.PI;\nconst angle360 = Math.PI * 2;\n\nexport function normRad (angle) {\n  let mod = angle % angle360;\n  if (mod < -angle180) {\n    mod += angle360;\n  } else if (mod > angle180) {\n    mod -= angle360;\n  }\n  return mod;\n}\n\nexport function acos (fValue) {\n  if (fValue > -1.0) {\n    if (fValue < 1.0) {\n      return Math.acos(fValue);\n    }\n    return 0.0;\n  }\n  return angle180;\n}\n\n// https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf page 50 & 51\n// https://stackoverflow.com/questions/24593939/matrix-multiplication-with-vector-in-glsl#answer-24594497\nexport function multiplyMat3Mat3 (matLeft, [mat0, mat1, mat2]) {\n  const [column0, column1, column2] = matLeft;\n  return new matLeft.constructor(\n    new column0.constructor(\n      column0.x * mat0.x + column1.x * mat0.y + column2.x * mat0.z,\n      column0.y * mat0.x + column1.y * mat0.y + column2.y * mat0.z,\n      column0.z * mat0.x + column1.z * mat0.y + column2.z * mat0.z\n    ),\n    new column0.constructor(\n      column0.x * mat1.x + column1.x * mat1.y + column2.x * mat1.z,\n      column0.y * mat1.x + column1.y * mat1.y + column2.y * mat1.z,\n      column0.z * mat1.x + column1.z * mat1.y + column2.z * mat1.z\n    ),\n    new column0.constructor(\n      column0.x * mat2.x + column1.x * mat2.y + column2.x * mat2.z,\n      column0.y * mat2.x + column1.y * mat2.y + column2.y * mat2.z,\n      column0.z * mat2.x + column1.z * mat2.y + column2.z * mat2.z\n    )\n  );\n}\n\nexport function multiplyMat3Vec (matLeft, { x, y, z }) {\n  const [column0, column1, column2] = matLeft;\n  return new column0.constructor(\n    column0.x * x + column1.x * y + column2.x * z,\n    column0.y * x + column1.y * y + column2.y * z,\n    column0.z * x + column1.z * y + column2.z * z\n  );\n}\n\nexport function multiplyVecMat3 (vecLeft, [column0, column1, column2]) {\n  return new vecLeft.constructor(\n    vecLeft.dot(column0),\n    vecLeft.dot(column1),\n    vecLeft.dot(column2)\n  );\n}\n\nexport function multiplyVecMat4 (vecLeft, [column0, column1, column2, column3]) {\n  return new vecLeft.constructor(\n    vecLeft.dot(column0),\n    vecLeft.dot(column1),\n    vecLeft.dot(column2),\n    vecLeft.dot(column3)\n  );\n}\n\nexport function isNumber (nr) {\n  if (typeof nr === 'number' || nr?.constructor === Number) {\n    return true;\n  }\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["operator_exports", "__export", "cachedFactory", "cachedFunction", "cachedGetter", "cachedMethod", "cachedValueOf", "defineMatrixLength", "defineVectorLength", "operatorCalc", "__toCommonJS", "angle360", "isNumber", "nr", "X", "Y", "Z", "W", "CHECK_SUM", "DEFAULT", "VECTOR_LENGTH", "GET_SOURCE", "CHECKED", "inProgress", "inVector", "elCount", "allChecks", "collect", "resultCacheIndex", "handlingCache", "resultCache", "handleProgess", "progess", "alg", "resVec", "res", "isNumber", "getVectorLength", "vec", "getSource", "maxVector", "v1", "v2", "getVectorValue", "index", "setVectorValue", "value", "operatorCalc", "result", "noRes", "funRes", "x", "inLen", "checkSum", "sum", "last", "i", "current", "len", "target", "val", "cachedValueOf", "VectorClass", "Vector", "name", "org", "bindCache", "args", "cachedMethod", "cachedGetter", "desc", "defineVectorLength", "defineMatrixLength", "MatrixClass", "cachedFactory", "cachedFunction", "fun"]
}
