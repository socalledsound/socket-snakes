var basics=basics||{};basics.vector=(()=>{var qt=Object.defineProperty;var yr=Object.getOwnPropertyDescriptor;var mr=Object.getOwnPropertyNames;var pr=Object.prototype.hasOwnProperty;var wr=(r,t)=>{for(var e in t)qt(r,e,{get:t[e],enumerable:!0})},dr=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of mr(t))!pr.call(r,o)&&o!==e&&qt(r,o,{get:()=>t[o],enumerable:!(n=yr(t,o))||n.enumerable});return r};var xr=r=>dr(qt({},"__esModule",{value:!0}),r);var Wr={};wr(Wr,{Color:()=>W,Degree:()=>it,FORWARD:()=>nt,IColor:()=>ft,IDENTITY:()=>ur,IDegree:()=>Z,IMat3:()=>Vt,IPoint:()=>A,IQuaternion:()=>ut,IVector:()=>et,LEFT:()=>ot,Point:()=>L,Quaternion:()=>ct,RIGHT:()=>Et,UP:()=>st,Vector:()=>T,Victor:()=>et,calc:()=>O,color:()=>hr,default:()=>Xr,degree:()=>X,degrees:()=>fr,fromOrientation:()=>cr,icolor:()=>lr,idegree:()=>er,ipoint:()=>lt,iquaternion:()=>at,ivector:()=>M,point:()=>vt,quaternion:()=>ir,radians:()=>ar,vector:()=>tr,victor:()=>M});function P(r){return Array.isArray(r)||ArrayBuffer.isView(r)}function pt(r,t){let{x:e,y:n,z:o}=t,{x:s,y:i,z:u,w:h}=r,c=h*e+i*o-u*n,f=h*n+u*e-s*o,d=h*o+s*n-i*e,q=-s*e-i*n-u*o,N=c*h+q*-s+f*-u-d*-i,mt=f*h+q*-i+d*-s-c*-u,a=d*h+q*-u+c*-i-f*-s;return new t.constructor(N,mt,a)}var bt=Math.PI,Nt=Math.PI*2;function G(r){let t=r%Nt;return t<-bt?t+=Nt:t>bt&&(t-=Nt),t}function Yt(r){return r>-1?r<1?Math.acos(r):0:bt}function Ut(r,[t,e,n]){let[o,s,i]=r;return new r.constructor(new o.constructor(o.x*t.x+s.x*t.y+i.x*t.z,o.y*t.x+s.y*t.y+i.y*t.z,o.z*t.x+s.z*t.y+i.z*t.z),new o.constructor(o.x*e.x+s.x*e.y+i.x*e.z,o.y*e.x+s.y*e.y+i.y*e.z,o.z*e.x+s.z*e.y+i.z*e.z),new o.constructor(o.x*n.x+s.x*n.y+i.x*n.z,o.y*n.x+s.y*n.y+i.y*n.z,o.z*n.x+s.z*n.y+i.z*n.z))}function Zt(r,{x:t,y:e,z:n}){let[o,s,i]=r;return new o.constructor(o.x*t+s.x*e+i.x*n,o.y*t+s.y*e+i.y*n,o.z*t+s.z*e+i.z*n)}function Qt(r,[t,e,n]){return new r.constructor(r.dot(t),r.dot(e),r.dot(n))}function x(r){return typeof r=="number"||(r==null?void 0:r.constructor)===Number}var ht=0,_t=1,Rt=2,Ft=3,dt=9999999999999,xt=void 0,Bt=Symbol("vector length"),zt=Symbol("get source"),$t=Symbol("checked"),S=xt,k,B,gr=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],Tt=[],_=-1,Ct=!1,wt=[];function At(r,t,e){S=r,_=-1,B=1;let n=t(e);if(!x(n))throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);return n}function gt(r){let t=r[zt];return t?t(r).length:r[Bt]||3}function zr(r,t){return gt(r)>gt(t)?r:t}function Sr(r,t){if(B+=1,t===dt)return B;if(t>=gt(r))return 0;let e=r[zt];if(e)return 1*e(r)[t];if(t===ht)return 1*r.x;if(t===_t)return 1*r.y;if(t===Rt)return 1*r.z;if(t===Ft)return 1*r.w}function jt(r,t,e){let n=r[zt];if(n){n(r)[t]=e;return}if(t===ht){r.x=e;return}if(t===_t){r.y=e;return}t===Rt&&(r.z=e),t===Ft&&(r.w=e)}function O(r,t){if(typeof r!="function")throw new Error("no function assigned");if(S!==xt)throw new Error("something wrong, do you use calc() inside calc?");try{let e=typeof t>"u",n=typeof t=="function",o=!n&&!e?t:void 0,s=At(ht,r,o);if(e&&typeof k>"u")return s;let i=k?gt(k):0;if(i===dt){if(!r[$t]){let f=At(dt,r),d=gr[B];if(Math.abs(f-d)>Number.EPSILON)throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);r[$t]=!0}let c=Tt[0];for(let f=1;f<B-1;f+=1){let d=Tt[f];if(!c.multiply)throw new Error(`cannot find method multiply() on ${c}`);c=c.multiply(d)}return c}let u=n?t.length:i;if(u||(u=i),u<i)throw new Error("Your assigned result Vector cant use higher space Operands than it has");let h=new Array(u);h[0]=s,o&&jt(o,S,h[0]);for(let c=1;c<u;c+=1){let f=At(c,r,o);h[c]=f,o&&jt(o,S,f)}return e?new k.constructor(...h):n?t(...h):o}finally{S=xt,k=void 0}}function b(r,t){let e=r.prototype;e[zt]=t;let n="valueOf",o=e[n];e[n]=function(){return S===ht&&(k=k?zr(k,this):this,Tt[B-1]=this),S===xt?o.call(this):Sr(this,S)}}function Jt(r){return function(...t){if(S===ht){if(Ct)return r.apply(this,t);try{Ct=!0,_+=1;let e=r.apply(this,t);return wt[_]=e,e}finally{Ct=!1}}return S===_t||S===Rt||S===Ft?(_+=1,wt[_]):r.apply(this,t)}}function m(r,t){let e=r.prototype,n=e[t];e[t]=Jt(n)}function K(r,t){let e=r.prototype,n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{get:Jt(function(){return n.get.call(this)})})}function U(r,t){let e=r.prototype;Object.defineProperty(e,Bt,{value:t})}function St(r){U(r,dt)}function E(r){return Jt(r)}function Er(r){let t="";return r&&(t=`${r}-`),t}function C(r,t,e={}){let n=Er(r);return Object.entries(t).forEach(([o,s])=>{e[`--${n}${o}`]=s}),e}var It=0,Dt=1,V=Symbol("axes");function Or(r,t,e,n){let o=Math.atan2(r,t),s=Math.atan2(e,n);return G(o-s)}function Kt(r){return r*r}var g=class{constructor(t,e){typeof t=="function"?O(t,(n,o)=>{this[V]=[n,o]}):P(t)?this[V]=[...t]:t&&x(t.x)?this[V]=[t.x||0,t.y||0]:this[V]=[t||0,e||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){let{length:t}=this;return new this.constructor(this.x/t,this.y/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y}getRad(){return G(Math.atan2(this.y,this.x))}angleTo(t){return Or(this.y,this.x,t.y,t.x)}rotate(t){let e=Math.sin(t),n=Math.cos(t),o=this.x*n-this.y*e,s=this.x*e+this.y*n;return new this.constructor(o,s)}distance(t){return Math.sqrt(Kt(this.x-t.x)+Kt(this.y-t.y))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y}toJSON(){return{x:this.x,y:this.y}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return C(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}get length(){return Math.sqrt(this.lengthSq)}get lensq(){return this.lengthSq}get len(){return this.length}get x(){return this[V][It]}set x(t){throw new Error("set x() not implemented")}get y(){return this[V][Dt]}set y(t){throw new Error("set y() not implemented")}get z(){throw new Error("get z() not implemented")}set z(t){throw new Error("set z() not implemented")}[Symbol.iterator](){return this[V].values()}};b(g);U(g,2);m(g,"dot");m(g,"angleTo");m(g,"distance");m(g,"toArray");m(g,"getRad");K(g,"length");K(g,"lengthSq");var L=class extends g{set x(t){this[V][It]=t}set y(t){this[V][Dt]=t}get x(){return this[V][It]}get y(){return this[V][Dt]}calc(t){return O(t,this)}clone(){return new L(this.x,this.y)}},A=class extends g{toPoint(){return new L(this.x,this.y)}};var Vr=E((r,t)=>new L(r,t)),vt=(r,t)=>Vr(r,t),Mr=E((r,t)=>new A(r,t)),lt=(r,t)=>Mr(r,t),vr=lt(0,0),te=lt(0,-1),re=lt(-1,0);var v=0,tt=1,rt=2,l=Symbol("axes");function Pt(r){return r*r}var w=class{constructor(t,e,n){typeof t=="function"?O(t,(o,s,i)=>{this[l]=[o,s,i]}):P(t)?this[l]=[...t]:t&&x(t.x)?this[l]=[t.x||0,t.y||0,t.z||0]:this[l]=[t||0,e||0,n||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){let{length:t}=this;return new this.constructor(this.x/t,this.y/t,this.z/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new this.constructor(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}crossNormalize(t){let e=this.cross(t),{length:n}=e;return e[l][v]/=n,e[l][tt]/=n,e[l][rt]/=n,e}cn(t){return this.crossNormalize(t)}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length)}}angleTo(t){return G(Yt(this.dot(t)/(this.length*t.length)))}multiply(t){return t.x===void 0?this.multiplyMat3(t):t.w===void 0?this.multiplyVec3(t):pt(t,this)}multiplyMat3(t){return Qt(this,t)}multiplyVec3({x:t,y:e,z:n}){return new this.constructor(this.x*t,this.y*e,this.z*n)}distance(t){return Math.sqrt(Pt(this.x-t.x)+Pt(this.y-t.y)+Pt(this.z-t.z))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y,this.z]}swizzle(t){let e=t.split("").map(n=>this[n]);return e.length===2?new A(e[0],e[1]):new this.constructor(e[0],e[1],e[2])}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}toJSON(){return{x:this.x,y:this.y,z:this.z}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return C(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}set lengthSq(t){throw new Error("set lengthSq() not implemented")}get length(){return Math.sqrt(this.lengthSq)}set length(t){throw new Error("set length() not implemented")}get lensq(){return this.lengthSq}set lensq(t){throw new Error("set lensq() not implemented")}get len(){return this.length}set len(t){throw new Error("set len() not implemented")}get x(){return this[l][v]}set x(t){throw new Error("set x() not implemented")}get y(){return this[l][tt]}set y(t){throw new Error("set y() not implemented")}get z(){return this[l][rt]}set z(t){throw new Error("set z() not implemented")}get xy(){return new A(this[l][v],this[l][tt])}set xy(t){throw new Error("set xz() not implemented")}get xz(){return new A(this[l][v],this[l][rt])}set xz(t){throw new Error("set xz() not implemented")}get yz(){return new A(this[l][tt],this[l][rt])}set yz(t){throw new Error("set yz() not implemented")}[Symbol.iterator](){return this[l].values()}};b(w);U(w,3);m(w,"dot");m(w,"cross");m(w,"crossNormalize");m(w,"toAngles");m(w,"angleTo");m(w,"rotate");m(w,"distance");m(w,"toArray");K(w,"length");K(w,"lengthSq");var T=class extends w{set x(t){this[l][v]=t}set y(t){this[l][tt]=t}set z(t){this[l][rt]=t}get x(){return this[l][v]}get y(){return this[l][tt]}get z(){return this[l][rt]}calc(t){return O(t,this)}clone(){return new T(this.x,this.y,this.z)}},et=class extends w{toVector(){return new T(this.x,this.y,this.z)}clone(){return this}};var qr=E((r,t,e)=>new T(r,t,e)),tr=(r,t,e)=>qr(r,t,e),Nr=E((r,t,e)=>new et(r,t,e)),M=(r,t,e)=>Nr(r,t,e),ce=M(0,0,0),nt=M(0,0,-1),ue=M(0,0,1),ot=M(-1,0,0),Et=M(1,0,0),st=M(0,1,0),he=M(0,-1,0),le=M(1,1,1);var R=Symbol("angle rad"),rr=Math.PI/180,me=180/Math.PI,H=class{constructor(t){t instanceof H?this[R]=t[R]:this[R]=G(t*rr)}valueOf(){return this[R]}toJSON(){return{angle:this[R]}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return C(t,this.toJSON(),e)}},it=class extends H{set(t){t instanceof H?this[R]=t[R]:this[R]=G((t||0)*rr)}},Z=class extends H{toDegree(){return new it(this[R])}},br=new Z(0);function X(r){return new it(r)}function er(r){return r instanceof Z?r:r?new Z(r):br}function nr(r){return x(r)||r instanceof H}var F=0,J=1,I=2,D=3,y=Symbol("axes"),Cr=Symbol("forward cache"),Ar=Symbol("left cache"),Tr=Symbol("up cache"),_r=Symbol("inverse cache");function Rr([r,t,e,n]){return Math.sqrt(r*r+t*t+e*e+n*n)}function or(r){let t=Rr(r);r[F]/=t,r[J]/=t,r[I]/=t,r[D]/=t}function Fr(r,t){let e=r.normalize(),n=t.crossNormalize(e),o=e.crossNormalize(n),s=n.x,i=n.y,u=n.z,h=o.x,c=o.y,f=o.z,d=e.x,q=e.y,N=e.z,mt=s+c+N,a=new Array(4);if(mt>0){let z=Math.sqrt(mt+1);return a[D]=z*.5,z=.5/z,a[F]=(f-q)*z,a[J]=(d-u)*z,a[I]=(i-h)*z,a}if(s>=c&&s>=N){let z=Math.sqrt(1+s-c-N),Y=.5/z;return a[F]=.5*z,a[J]=(i+h)*Y,a[I]=(u+d)*Y,a[D]=(f-q)*Y,a}if(c>N){let z=Math.sqrt(1+c-s-N),Y=.5/z;return a[F]=(h+i)*Y,a[J]=.5*z,a[I]=(q+f)*Y,a[D]=(d-u)*Y,a}let Wt=Math.sqrt(1+N-s-c),Mt=.5/Wt;return a[F]=(d+u)*Mt,a[J]=(q+f)*Mt,a[I]=.5*Wt,a[D]=(i-h)*Mt,a}function Jr(r,t){let e=new Array(4),n=t*.5,o=Math.sin(n),s=Math.cos(n);return e[F]=o*r.x,e[J]=o*r.y,e[I]=o*r.z,e[D]=s,e}function Gt(r,t,e,n){if(x(r))return[r,t,e,n];if(P(r))return[...r];if(nr(t))return Jr(r,t);if(r&&t)return Fr(r,t)}function sr(r,t,e,n){return r&&x(r.w)?Gt(r.x,r.y,r.z,r.w):Gt(r,t,e,n)||[0,0,0,1]}var Q=class{constructor(t,e,n,o){this[y]=sr(t,e,n,o),or(this[y])}set(t,e,n,o){throw new Error("set x() not implemented")}multiply(t,e,n,o){if(x(t.w))return this.multiplyQuaternion(t);let s=Gt(t,e,n,o);return s?this.multiplyQuaternion(new this.constructor(s)):this.multiplyVector(t)}multiplyVector(t){return pt(this,t)}multiplyQuaternion(t){let e=this.x,n=this.y,o=this.z,s=this.w,i=t.x,u=t.y,h=t.z,c=t.w,f=s*i+e*c+n*h-o*u,d=s*u+n*c+o*i-e*h,q=s*h+o*c+e*u-n*i,N=s*c-e*i-n*u-o*h;return new this.constructor(f,d,q,N)}mul(t,e,n,o){return this.multiply(t,e,n,o)}get inverse(){let{x:t,y:e,z:n,w:o}=this;return this.constructor(t*-1,e*-1,n*-1,o)}get inv(){return this.inverse}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}get left(){return this.multiplyVector(ot)}get dir(){return this.multiplyVector(nt)}get up(){return this.multiplyVector(st)}get[0](){return this.left}get[1](){return this.dir}get[2](){return this.up}get x(){return this[y][F]}set x(t){throw new Error("set x() not implemented")}get y(){return this[y][J]}set y(t){throw new Error("set y() not implemented")}get z(){return this[y][I]}set z(t){throw new Error("set z() not implemented")}get w(){return this[y][D]}set w(t){throw new Error("set w() not implemented")}toJSON(){let{x:t,y:e,z:n,w:o}=this;return{x:t,y:e,z:n,w:o,a1:1-e*e*2-n*n*2,a2:t*e*2-n*o*2,a3:t*n*2+e*o*2,b1:t*e*2+n*o*2,b2:1-t*t*2-n*n*2,b3:e*n*2-t*o*2,c1:t*n*2-e*o*2,c2:e*n*2+t*o*2,c3:1-t*t*2-e*e*2}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return C(t,this.toJSON(),e)}};b(Q);St(Q);var ct=class extends Q{set(t,e,n,o){t instanceof Q?this[y]=[...t[y]]:(this[y]=sr(t,e,n,o),or(this[y]))}set x(t){this[y][F]=t}set y(t){this[y][J]=t}set z(t){this[y][I]=t}set w(t){this[y][D]=t}get x(){return this[y][F]}get y(){return this[y][J]}get z(){return this[y][I]}get w(){return this[y][D]}};function Ot(r,t,e){let n=r[t];return n||(n=e(),r[t]=n),n}var ut=class extends Q{get left(){return Ot(this,Ar,()=>this.multiplyVector(ot))}get dir(){return Ot(this,Cr,()=>this.multiplyVector(nt))}get up(){return Ot(this,Tr,()=>this.multiplyVector(st))}get inverse(){return Ot(this,_r,()=>{let{x:t,y:e,z:n,w:o}=this;return this.constructor(t*-1,e*-1,n*-1,o)})}},Se=new ct,Ir=E((r,t,e,n)=>new ct(r,t,e,n)),ir=(r,t,e,n)=>Ir(r,t,e,n),Dr=E((r,t,e,n)=>new ut(r,t,e,n)),at=(r,t,e,n)=>Dr(r,t,e,n),Pr=new ut(ot,X(90));function cr({alpha:r,beta:t,gamma:e},n){let o=at(st,X(r)).mul(Et,X(t)).mul(nt,X(e)).mul(Pr);return o=at(o.dir,X(n)).mul(o),o}var ur=at(0,0,0,1);var kt=0,Lt=1,Ht=2,Xt=3,p=Symbol("axes"),$=class{constructor(t,e,n,o){typeof t=="function"?O(t,(s,i,u,h)=>{this[p]=[s,i,u,h]}):P(t)?this[p]=[...t]:t&&x(t.x)?this[p]=[t.x||0,t.y||0,t.z||0,t.w||0]:this[p]=[t||0,e||0,n||0,o||0]}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}toArray(){return[this.x,this.y,this.z,this.w]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}toJSON(){return{x:this.x,y:this.y,z:this.z,w:this.w}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e){return C(t,this.toJSON(),e)}get x(){return this[p][kt]}set x(t){throw new Error("set x() not implemented")}get y(){return this[p][Lt]}set y(t){throw new Error("set y() not implemented")}get z(){return this[p][Ht]}set z(t){throw new Error("set z() not implemented")}get w(){return this[p][Xt]}set w(t){throw new Error("set w() not implemented")}[Symbol.iterator](){return this[p].values()}};b($);U($,4);m($,"toArray");var W=class extends ${set x(t){this[p][kt]=t}set y(t){this[p][Lt]=t}set z(t){this[p][Ht]=t}set w(t){this[p][Xt]=t}get x(){return this[p][kt]}get y(){return this[p][Lt]}get z(){return this[p][Ht]}get w(){return this[p][Xt]}calc(t){return O(t,this)}clone(){return new W(this.x,this.y)}},ft=class extends ${toColor(){return new W(this.x,this.y,this.z,this.w)}};var Gr=E((r,t,e,n)=>new W(r,t,e,n)),hr=(r,t,e,n)=>Gr(r,t,e,n),kr=E((r,t,e,n)=>new ft(r,t,e,n)),lr=(r,t,e,n)=>kr(r,t,e,n);var yt=Symbol("data"),j=class{constructor(...t){this[yt]=t}get[0](){return this[yt][0]}set[0](t){throw new Error("set [0] not implemented")}get[1](){return this[yt][1]}set[1](t){throw new Error("set [1] not implemented")}get[2](){return this[yt][2]}set[2](t){throw new Error("set [2] not implemented")}multiplyMat(t){return Ut(this,t)}multiplyVec(t){return Zt(this,t)}multiply(t){if(t instanceof j)return this.multiplyMat(t);let{x:e,y:n,z:o}=t;if(e===void 0||n===void 0||o===void 0)throw new Error(`multiply only works with mat3 and vec3, not supported ${t}`);return this.multiplyVec(t)}[Symbol.iterator](){return this[yt].values()}};b(j);St(j);var Vt=class extends j{};var Lr=Math.PI/180,Hr=180/Math.PI;function ar(r){return r*Lr}function fr(r){return r*Hr}var Xr=T;return xr(Wr);})();
//# sourceMappingURL=index.js.map
